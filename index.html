<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>iSchool Program–Course Network (Standalone)</title>
    <!-- Tailwind via CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 UMD builds + Babel for in-browser JSX -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- D3 and PapaParse UMD -->
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
      html, body, #root { height: 100%; }
      body { margin: 0; background: white; }
      svg text { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      // Strong, contrasting palette for program colors
      const PROGRAM_PALETTE = [
        "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
        "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
        "#4e79a7", "#f28e2c", "#e15759", "#76b7b2", "#59a14f",
        "#edc948", "#b07aa1", "#ff9da7", "#9c755f", "#bab0ac"
      ];

      // Build nodes (programs, courses) and edges from CSV rows {Program, Course}
      function buildGraph(rows) {
        const normalized = rows.map((r) => {
          const obj = {}; for (const k in r) obj[k.trim()] = (r[k] ?? "").trim(); return obj;
        });
        const sample = normalized[0] || {};
        const programKey = Object.keys(sample).find((k) => /program/i.test(k)) || "Program";
        const courseKey  = Object.keys(sample).find((k) => /course/i.test(k)) || "Course";

        const nodesMap = new Map();
        const edges = [];
        let colorIdx = 0;

        function ensureNode(id, type) {
          if (!nodesMap.has(id)) {
            nodesMap.set(id, { id, type });
            if (type === "program") {
              const c = PROGRAM_PALETTE[colorIdx % PROGRAM_PALETTE.length];
              nodesMap.get(id).color = c;
              colorIdx += 1;
            } else {
              nodesMap.get(id).color = "#444"; // neutral for courses
            }
          }
        }

        normalized.forEach((row, i) => {
          const program = String(row[programKey] ?? "").trim();
          const course  = String(row[courseKey]  ?? "").trim();
          if (!program || !course) return;
          ensureNode(program, "program");
          ensureNode(course,  "course");
          edges.push({ id: `e${i}`, source: program, target: course, program });
        });

        // Degree counts
        const degree = new Map();
        edges.forEach((e) => {
          degree.set(e.source, (degree.get(e.source) || 0) + 1);
          degree.set(e.target, (degree.get(e.target) || 0) + 1);
        });
        nodesMap.forEach((n) => n.degree = degree.get(n.id) || 0);

        return { nodes: Array.from(nodesMap.values()), edges };
      }

      // Graph helpers
      function buildAdjacency(nodes, edges) {
        const idToIndex = new Map();
        nodes.forEach((n, i) => idToIndex.set(n.id, i));
        const adj = Array.from({ length: nodes.length }, () => []);
        edges.forEach((e) => { const u = idToIndex.get(e.source), v = idToIndex.get(e.target); adj[u].push(v); adj[v].push(u); });
        return { idToIndex, adj };
      }

      function connectedComponents(nodes, adj) {
        const n = nodes.length; const seen = new Array(n).fill(false); const comps = [];
        for (let i = 0; i < n; i++) {
          if (seen[i]) continue; const stack = [i]; seen[i] = true; const comp = [];
          while (stack.length) { const u = stack.pop(); comp.push(u); for (const v of adj[u]) if (!seen[v]) { seen[v] = true; stack.push(v); } }
          comps.push(comp);
        }
        return comps;
      }

      function allPairsShortestPaths(adj) {
        const n = adj.length; const dist = Array.from({ length: n }, () => new Array(n).fill(Infinity));
        for (let s = 0; s < n; s++) {
          const q = [s]; dist[s][s] = 0; let qi = 0;
          while (qi < q.length) { const u = q[qi++]; for (const v of adj[u]) if (dist[s][v] === Infinity) { dist[s][v] = dist[s][u] + 1; q.push(v); } }
        }
        return dist;
      }

      // Kamada–Kawai on a component, then components are packed in a grid
      function kamadaKawaiLayout(nodes, edges, comp) {
        const { adj } = buildAdjacency(nodes, edges);
        const distAll = allPairsShortestPaths(adj);
        const idxArr = comp; const m = idxArr.length;
        const pairs = []; let sumL = 0, cntL = 0;
        for (let a = 0; a < m; a++) for (let b = a + 1; b < m; b++) { const i = idxArr[a], j = idxArr[b]; const d = distAll[i][j]; if (!isFinite(d) || d === 0) continue; sumL += d; cntL += 1; }
        const L0 = cntL ? 1 / (sumL / cntL) : 1;
        for (let a = 0; a < m; a++) for (let b = a + 1; b < m; b++) { const i = idxArr[a], j = idxArr[b]; const d = distAll[i][j]; if (!isFinite(d) || d === 0) continue; const lij = L0 * d; const wij = 1 / (d * d); pairs.push([a, b, lij, wij]); }
        const pos = Array.from({ length: m }, (_, k) => ({ x: 0.5 + 0.4 * Math.cos((2 * Math.PI * k) / m), y: 0.5 + 0.4 * Math.sin((2 * Math.PI * k) / m) }));
        const T = Math.min(600, 100 + 20 * m); let step = 0.02;
        for (let t = 0; t < T; t++) {
          const grad = Array.from({ length: m }, () => ({ x: 0, y: 0 }));
          for (const [a, b, lij, wij] of pairs) {
            const dx = pos[a].x - pos[b].x, dy = pos[a].y - pos[b].y; const d = Math.hypot(dx, dy) || 1e-6;
            const coeff = 2 * wij * (1 - lij / d); const gx = coeff * dx, gy = coeff * dy;
            grad[a].x += gx; grad[a].y += gy; grad[b].x -= gx; grad[b].y -= gy;
          }
          for (let a = 0; a < m; a++) { pos[a].x -= step * grad[a].x; pos[a].y -= step * grad[a].y; }
          if ((t + 1) % 50 === 0) step *= 0.7;
        }
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (let a = 0; a < m; a++) { minX = Math.min(minX, pos[a].x); maxX = Math.max(maxX, pos[a].x); minY = Math.min(minY, pos[a].y); maxY = Math.max(maxY, pos[a].y); }
        const scaleX = maxX - minX || 1, scaleY = maxY - minY || 1;
        const out = {};
        for (let a = 0; a < m; a++) { const id = nodes[idxArr[a]].id; out[id] = { x: (pos[a].x - minX) / scaleX, y: (pos[a].y - minY) / scaleY }; }
        return out;
      }

      function forceDirectedLayout(nodes, edges) {
        const idToNode = new Map(nodes.map((n) => [n.id, { x: Math.random(), y: Math.random() }]));
        const sim = d3.forceSimulation(nodes.map((n) => ({ id: n.id, x: idToNode.get(n.id).x * 500, y: idToNode.get(n.id).y * 500 })))
          .force("link", d3.forceLink(edges.map((e) => ({ source: e.source, target: e.target }))).id((d) => d.id).distance(50).strength(0.8))
          .force("charge", d3.forceManyBody().strength(-200))
          .force("center", d3.forceCenter(250, 250))
          .stop();
        sim.tick(200);
        const out = {}; (sim.nodes()).forEach((n) => { out[n.id] = { x: (n.x || 0) / 500, y: (n.y || 0) / 500 }; });
        return out;
      }

      function circularLayout(nodes) {
        const n = nodes.length; const out = {};
        nodes.forEach((node, i) => { out[node.id] = { x: 0.5 + 0.45 * Math.cos((2 * Math.PI * i) / n), y: 0.5 + 0.45 * Math.sin((2 * Math.PI * i) / n) }; });
        return out;
      }

      function bipartiteLayout(nodes, edges) {
        const programs = nodes.filter((n) => n.type === "program");
        const courses = nodes.filter((n) => n.type === "course");
        const out = {};
        programs.forEach((n, i) => { out[n.id] = { x: 0.2, y: 0.1 + (0.8 * i) / Math.max(1, programs.length - 1) }; });
        courses.forEach((n, i) => { out[n.id] = { x: 0.8, y: 0.1 + (0.8 * i) / Math.max(1, courses.length - 1) }; });
        return out;
      }

      // New layouts
      function randomLayout(nodes) {
        const out = {};
        nodes.forEach((n) => { out[n.id] = { x: Math.random(), y: Math.random() }; });
        return out;
      }

      function spiralLayout(nodes) {
        const out = {};
        const golden = Math.PI * (3 - Math.sqrt(5)); // golden angle
        const n = nodes.length;
        nodes.forEach((node, i) => {
          const t = i / Math.max(1, n - 1);
          const r = 0.1 + 0.4 * t;
          const a = i * golden;
          out[node.id] = { x: 0.5 + r * Math.cos(a), y: 0.5 + r * Math.sin(a) };
        });
        return out;
      }

      function concentricDegreeLayout(nodes) {
        const out = {};
        const maxDeg = nodes.reduce((m, n) => Math.max(m, n.degree || 0), 0);
        const rings = 4;
        const ringNodes = Array.from({ length: rings }, () => []);
        nodes.forEach((n) => {
          const d = n.degree || 0;
          const bucket = maxDeg > 0 ? Math.max(0, Math.min(rings - 1, rings - 1 - Math.floor((d / maxDeg) * (rings - 1)))) : rings - 1;
          ringNodes[bucket].push(n);
        });
        const radii = [0.15, 0.30, 0.45, 0.60];
        ringNodes.forEach((arr, rIndex) => {
          const m = arr.length || 1;
          arr.forEach((n, i) => {
            const a = (2 * Math.PI * i) / m;
            out[n.id] = { x: 0.5 + radii[rIndex] * Math.cos(a), y: 0.5 + radii[rIndex] * Math.sin(a) };
          });
        });
        return out;
      }

      function computePositions(nodes, edges, layout) {
        if (layout === "Circular") return circularLayout(nodes);
        if (layout === "Force-Directed") return forceDirectedLayout(nodes, edges);
        if (layout === "Bipartite") return bipartiteLayout(nodes, edges);
        if (layout === "Random") return randomLayout(nodes);
        if (layout === "Spiral") return spiralLayout(nodes);
        if (layout === "Concentric (Degree)") return concentricDegreeLayout(nodes);
        // default KK with component packing
        const { adj } = buildAdjacency(nodes, edges); const comps = connectedComponents(nodes, adj);
        const perComp = []; const positions = {};
        for (const comp of comps) { const kk = kamadaKawaiLayout(nodes, edges, comp); const pts = comp.map((idx) => ({ id: nodes[idx].id, x: kk[nodes[idx].id].x, y: kk[nodes[idx].id].y })); perComp.push(pts); }
        const cols = Math.ceil(Math.sqrt(perComp.length));
        perComp.forEach((pts, i) => { const gx = i % cols, gy = Math.floor(i / cols); const offsetX = (gx + 0.5) / cols, offsetY = (gy + 0.5) / cols; const scale = 0.8 / cols; pts.forEach((p) => { positions[p.id] = { x: offsetX + scale * (p.x - 0.5), y: offsetY + scale * (p.y - 0.5) }; }); });
        return positions;
      }

      // Steeper node sizing by degree (superlinear mapping)
      function radiusForNode(n, maxDeg) {
        const d = n.degree || 0;
        const minR = 5, maxR = 36;
        if (maxDeg <= 1) return minR;
        const t = Math.pow(d / maxDeg, 1.4); // steeper than linear
        return minR + (maxR - minR) * t;
      }

      function download(filename, href) { const a = document.createElement("a"); a.href = href; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); }
      function exportSVG(svgRef) {
        const svg = svgRef.current; if (!svg) return; const serializer = new XMLSerializer(); const copy = svg.cloneNode(true);
        const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect"); bg.setAttribute("x", "0"); bg.setAttribute("y", "0"); bg.setAttribute("width", String(svg.clientWidth)); bg.setAttribute("height", String(svg.clientHeight)); bg.setAttribute("fill", "white"); copy.insertBefore(bg, copy.firstChild);
        const str = serializer.serializeToString(copy); const blob = new Blob([str], { type: "image/svg+xml;charset=utf-8" }); const url = URL.createObjectURL(blob); download("network.svg", url); URL.revokeObjectURL(url);
      }
      async function exportPNG(svgRef) {
        const svg = svgRef.current; if (!svg) return; const serializer = new XMLSerializer(); const copy = svg.cloneNode(true);
        const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect"); bg.setAttribute("x", "0"); bg.setAttribute("y", "0"); bg.setAttribute("width", String(svg.clientWidth)); bg.setAttribute("height", String(svg.clientHeight)); bg.setAttribute("fill", "white"); copy.insertBefore(bg, copy.firstChild);
        const str = serializer.serializeToString(copy); const svgBlob = new Blob([str], { type: "image/svg+xml;charset=utf-8" }); const url = URL.createObjectURL(svgBlob); const img = new Image(); const canvas = document.createElement("canvas"); canvas.width = svg.clientWidth; canvas.height = svg.clientHeight; const ctx = canvas.getContext("2d"); await new Promise((resolve) => { img.onload = () => resolve(); img.src = url; }); ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); URL.revokeObjectURL(url); download("network.png", canvas.toDataURL("image/png"));
      }

      function App() {
        const [rows, setRows] = useState([]);
        const [nodes, setNodes] = useState([]);
        const [edges, setEdges] = useState([]);
        const [layoutName, setLayoutName] = useState("Kamada–Kawai");
        const [positions, setPositions] = useState({});
        const [showLabels, setShowLabels] = useState(true);
        const [labelPrograms, setLabelPrograms] = useState(new Set());
        const [selectedNode, setSelectedNode] = useState(null);
        const [search, setSearch] = useState("");
        const [fixed, setFixed] = useState(new Set());

        const svgRef = useRef(null); const zoomRef = useRef(null); const gRef = useRef(null);
        const containerRef = useRef(null); const [size, setSize] = useState({ width: 800, height: 600 });

        useEffect(() => { if (!rows.length) return; const { nodes, edges } = buildGraph(rows); setNodes(nodes); setEdges(edges); }, [rows]);

        useEffect(() => {
          if (!nodes.length) return; const base = computePositions(nodes, edges, layoutName); const merged = { ...base }; for (const id of fixed) if (positions[id]) merged[id] = positions[id]; setPositions(merged);
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [nodes, edges, layoutName]);

        useEffect(() => { const el = containerRef.current; if (!el) return; const ro = new ResizeObserver(() => { setSize({ width: el.clientWidth, height: el.clientHeight }); }); ro.observe(el); return () => ro.disconnect(); }, []);

        useEffect(() => {
          const svg = svgRef.current; const g = gRef.current; if (!svg || !g) return; const zoomed = (event) => { const { transform } = event; g.setAttribute("transform", transform.toString()); };
          const zoom = d3.zoom().scaleExtent([0.2, 10]).on("zoom", zoomed); d3.select(svg).call(zoom); zoomRef.current = zoom;
        }, []);

        const idToNode = useMemo(() => new Map(nodes.map((n) => [n.id, n])), [nodes]);
        const programList = useMemo(() => nodes.filter((n) => n.type === "program").map((n) => n.id).sort(), [nodes]);
        const maxDegree = useMemo(() => nodes.reduce((m, n) => Math.max(m, n.degree || 0), 0), [nodes]);
        const margin = 24; const toScreen = (p) => ({ x: margin + (p.x || 0.5) * (size.width - 2 * margin), y: margin + (p.y || 0.5) * (size.height - 2 * margin) });

        const neighbors = useMemo(() => { const map = new Map(); nodes.forEach((n) => map.set(n.id, new Set())); edges.forEach((e) => { map.get(e.source).add(e.target); map.get(e.target).add(e.source); }); return map; }, [nodes, edges]);
        const isEdgeActive = (e) => !selectedNode || e.source === selectedNode || e.target === selectedNode;
        const isNodeDimmed = (id) => selectedNode && !(id === selectedNode || neighbors.get(selectedNode).has(id));
        const handleBackgroundClick = () => setSelectedNode(null);

        // Drag behavior on entire node group; robust to zoom via inverse transform
        const drag = d3.drag()
          .on("start", function(event) {
            event.sourceEvent?.stopPropagation?.();
            const group = event.sourceEvent?.target?.closest?.("g.node-group");
            const id = group?.getAttribute ? group.getAttribute("data-id") : null;
            if (!id) return;
            setSelectedNode(id);
            setFixed((prev) => new Set([...prev, id]));
          })
          .on("drag", function(event) {
            const svg = svgRef.current; if (!svg) return;
            const group = event.sourceEvent?.target?.closest?.("g.node-group");
            const id = group?.getAttribute ? group.getAttribute("data-id") : null;
            if (!id) return;
            const z = d3.zoomTransform(svg);
            const pt = z.invert([event.x, event.y]);
            const ux = pt[0], uy = pt[1];
            const px = (ux - margin) / Math.max(1, size.width - 2 * margin);
            const py = (uy - margin) / Math.max(1, size.height - 2 * margin);
            setPositions((prev) => ({ ...prev, [id]: { x: Math.max(0, Math.min(1, px)), y: Math.max(0, Math.min(1, py)) } }));
          })
          .on("end", function(event) {
            const group = event.sourceEvent?.target?.closest?.("g.node-group");
            const id = group?.getAttribute ? group.getAttribute("data-id") : null;
            if (!id) return;
            setFixed((prev) => new Set([...prev, id]));
          });

        // Apply drag to all node groups
        useEffect(() => {
          const svg = svgRef.current; if (!svg) return;
          const sel = d3.select(svg).selectAll("g.node-group");
          sel.call(drag);
        });

        function runSearch() {
          const q = search.trim().toLowerCase(); if (!q) return; const match = nodes.find((n) => n.id.toLowerCase().includes(q)); if (!match) return; setSelectedNode(match.id);
          const svg = svgRef.current; const p = toScreen(positions[match.id] || { x: 0.5, y: 0.5 }); const current = d3.zoomTransform(svg); const k = current.k || 1; const tx = size.width / 2 - k * p.x; const ty = size.height / 2 - k * p.y; d3.select(svg).transition().duration(500).call(zoomRef.current.transform, d3.zoomIdentity.translate(tx, ty).scale(k));
        }

        function onFileSelected(file) { Papa.parse(file, { header: true, skipEmptyLines: true, complete: (res) => { const data = (res.data || []).filter(Boolean); setRows(data); } }); }
        function resetView() { const svg = svgRef.current; if (!svg) return; d3.select(svg).transition().duration(400).call(zoomRef.current.transform, d3.zoomIdentity); setSelectedNode(null); }
        function resetPositions() { setFixed(new Set()); setPositions(computePositions(nodes, edges, layoutName)); }
        function edgePath(e) { const a = toScreen(positions[e.source] || { x: 0.5, y: 0.5 }); const b = toScreen(positions[e.target] || { x: 0.5, y: 0.5 }); return `M${a.x},${a.y} L${b.x},${b.y}`; }
        function showLabelFor(id) {
          if (!showLabels) return false; if (labelPrograms.size === 0) return true; const n = idToNode.get(id); if (n.type === "program") return labelPrograms.has(n.id); const inc = edges.filter((e) => e.target === id || e.source === id).map((e) => e.program); return inc.some((p) => labelPrograms.has(p));
        }

        const drawableEdges = edges; const drawableNodes = nodes;

        return (
          <div className="w-full h-screen bg-white text-gray-900 flex">
            {/* Sidebar Controls */}
            <div className="w-80 flex-shrink-0 border-r border-gray-200 p-4 space-y-4 overflow-y-auto">
              <h1 className="text-xl font-semibold">iSchool Program–Course Network</h1>
              <p className="text-sm text-gray-600">Upload a CSV with columns <span className="font-mono">Program</span> and <span className="font-mono">Course</span>.</p>

              <div>
                <label className="block text-sm font-medium mb-1">Load data (CSV)</label>
                <input type="file" accept=".csv" onChange={(e) => e.target.files && onFileSelected(e.target.files[0])} className="block w-full text-sm" />
                <div className="mt-2 text-xs text-gray-500">{rows.length ? `${rows.length} rows loaded` : `No data loaded yet`}</div>
              </div>

              <div className="space-y-1">
                <label className="block text-sm font-medium">Layout</label>
                <select value={layoutName} onChange={(e) => setLayoutName(e.target.value)} className="w-full border rounded-md px-2 py-1">
                  <option>Kamada–Kawai</option>
                  <option>Force-Directed</option>
                  <option>Circular</option>
                  <option>Bipartite</option>
                  <option>Random</option>
                  <option>Spiral</option>
                  <option>Concentric (Degree)</option>
                </select>
                <div className="flex gap-2 pt-2">
                  <button className="px-3 py-1.5 bg-gray-900 text-white rounded-md" onClick={resetPositions}>Reset positions</button>
                  <button className="px-3 py-1.5 bg-gray-100 rounded-md" onClick={resetView}>Reset view</button>
                </div>
              </div>

              <div className="space-y-2">
                <label className="inline-flex items-center gap-2 text-sm">
                  <input type="checkbox" checked={showLabels} onChange={(e) => setShowLabels(e.target.checked)} />
                  Show labels
                </label>
                <div>
                  <div className="text-sm font-medium mb-1">Filter labels by program</div>
                  <div className="h-32 overflow-y-auto border rounded-md p-2 space-y-1">
                    {programList.map((p) => (
                      <label key={p} className="flex items-center gap-2 text-sm">
                        <input type="checkbox" checked={labelPrograms.has(p)} onChange={(e) => { setLabelPrograms((prev) => { const n = new Set(prev); if (e.target.checked) n.add(p); else n.delete(p); return n; }); }} />
                        <span className="inline-flex items-center gap-2">
                          <span className="w-3 h-3 inline-block rounded-sm" style={{ background: idToNode.get(p)?.color || "#000" }} /> {p}
                        </span>
                      </label>
                    ))}
                  </div>
                  <div className="mt-1">
                    <button className="text-xs underline text-gray-600 mr-3" onClick={() => setLabelPrograms(new Set())}>Clear</button>
                    <button className="text-xs underline text-gray-600" onClick={() => setLabelPrograms(new Set(programList))}>All</button>
                  </div>
                </div>
              </div>

              <div className="space-y-2">
                <label className="block text-sm font-medium">Search node</label>
                <div className="flex gap-2">
                  <input value={search} onChange={(e) => setSearch(e.target.value)} onKeyDown={(e) => e.key === "Enter" && runSearch()} placeholder="Type a course or program" className="border rounded-md px-2 py-1 flex-1" />
                  <button onClick={runSearch} className="px-3 py-1.5 bg-blue-600 text-white rounded-md">Go</button>
                </div>
                <p className="text-xs text-gray-600">When a node is selected, only its incident edges keep their color, others turn gray. Click empty space to clear.</p>
              </div>

              <div className="space-y-2">
                <div className="text-sm font-medium">Export view</div>
                <div className="flex gap-2">
                  <button onClick={() => exportPNG(svgRef)} className="px-3 py-1.5 bg-green-600 text-white rounded-md">PNG</button>
                  <button onClick={() => exportSVG(svgRef)} className="px-3 py-1.5 bg-gray-900 text-white rounded-md">SVG</button>
                </div>
              </div>

              <div className="pt-2 text-xs text-gray-500">
                <p>Drag nodes to reposition, they will stick until you reset positions. Scroll or pinch to zoom, drag to pan.</p>
              </div>
            </div>

            {/* Graph Canvas */}
            <div className="flex-1" ref={containerRef}>
              <svg ref={svgRef} width={size.width} height={size.height} className="bg-white" onClick={(e) => { if (e.target === e.currentTarget) handleBackgroundClick(); }}>
                <g ref={gRef}>
                  {/* Edges */}
                  {drawableEdges.map((e) => { const programColor = idToNode.get(e.program)?.color || "#999"; const stroke = isEdgeActive(e) ? programColor : "#ccc"; return (<path key={e.id} d={edgePath(e)} stroke={stroke} strokeWidth={1.6} fill="none" opacity={isEdgeActive(e) ? 0.9 : 0.6} />); })}

                  {/* Nodes */}
                  {drawableNodes.map((n) => {
                    const p = toScreen(positions[n.id] || { x: 0.5, y: 0.5 });
                    const r = radiusForNode(n, maxDegree);
                    const fill = n.type === "program" ? (n.color || "#000") : "#666";
                    const stroke = selectedNode === n.id ? "#111" : "#fff";
                    const opacity = isNodeDimmed(n.id) ? 0.25 : 1;
                    const isIST = n.type === "course" && /^\s*IST\b/i.test(n.id);
                    const labelFill = n.type === "course" ? (isIST ? "#000" : "#d00") : "#111";
                    return (
                      <g className="node-group" data-id={n.id} key={n.id} transform={\`translate(\${p.x},\${p.y})\`} style={{ cursor: "pointer" }} onClick={(ev) => { ev.stopPropagation(); setSelectedNode(n.id); }}>
                        <circle className="node" data-id={n.id} r={r} fill={fill} stroke={stroke} strokeWidth={1.5} opacity={opacity} />
                        {showLabelFor(n.id) && (
                          <text x={0} y={-(r + 6)} textAnchor="middle" fontSize={n.type === "program" ? 14 : 12} fontWeight={n.type === "program" ? 700 : 400} fill={labelFill} className="select-none" style={{ pointerEvents: "none" }}>{n.id}</text>
                        )}
                      </g>
                    );
                  })}
                </g>
              </svg>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
